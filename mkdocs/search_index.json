{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nclj-fakes is an isolation framework for Clojure/ClojureScript. It makes creating mocks and stubs for unit testing much easier.\n\n\nOne of the unique features of the framework is the ability to find unused fakes in order to help users write more concise test cases.\n\n\nFeatures\n\n\n\n\nAll test doubles are named \"fakes\" to simplify terminology\n\n\nFakes can be created for:\n\n\nprotocol instances\n\n\nfunctions\n\n\n\n\n\n\n\"Nice\" and \"strict\" protocol fakes are supported\n\n\nMonkey patching is supported to fake implicit dependencies\n\n\nSelf-testing: automatically checks for unused fakes\n\n\nTest runner agnostic\n\n\nArrange-Act-Assert style testing\n\n\n\n\nInstallation\n\n\nAdd this to your dependencies in project.clj:\n\n\n[clj-fakes \n0.1.1-SNAPSHOT\n]", 
            "title": "Home"
        }, 
        {
            "location": "/#introduction", 
            "text": "clj-fakes is an isolation framework for Clojure/ClojureScript. It makes creating mocks and stubs for unit testing much easier.  One of the unique features of the framework is the ability to find unused fakes in order to help users write more concise test cases.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#features", 
            "text": "All test doubles are named \"fakes\" to simplify terminology  Fakes can be created for:  protocol instances  functions    \"Nice\" and \"strict\" protocol fakes are supported  Monkey patching is supported to fake implicit dependencies  Self-testing: automatically checks for unused fakes  Test runner agnostic  Arrange-Act-Assert style testing", 
            "title": "Features"
        }, 
        {
            "location": "/#installation", 
            "text": "Add this to your dependencies in project.clj:  [clj-fakes  0.1.1-SNAPSHOT ]", 
            "title": "Installation"
        }, 
        {
            "location": "/user-guide/", 
            "text": "Namespaces\n\n\nThe public API is split into two namespaces:\n\n\n\n\nclj-fakes.core\n\n\nclj-fakes.context\n\n\n\n\nThis is how you could require them in Clojure and ClojureScript:\n\n\n; Clojure\n(ns unit.example\n  (:require\n    [clj-fakes.core :as f]\n    [clj-fakes.context :as fc]))\n\n; ClojureScript\n(ns unit.example\n  (:require\n    [clj-fakes.core :as f :include-macros true]\n    [clj-fakes.context :as fc :include-macros true]))\n\n\n\n\nThese namespaces contain almost the same set of members. The difference \nis that \ncore\n uses an implicit context and the \ncontext\n namespace\nfunctions require an explicit context argument.\n\n\nFor your convenience functions which don't rely on a context can also be sometimes found in both namespaces (e.g. \nf/any?\n is the same as \nfc/any?\n).\n\n\nThe private/internal API uses a \n-\n prefix and should not be used (e.g. \n-this-is-some-private-thing\n).\n\n\nContext\n\n\nContext is an object which stores all the information about\ncreated fakes (recorded calls, positions in code, etc.).\nAll fakes have to be created inside some context.\n\n\nTo create a new context use \nclj-fakes.context/context\n:\n\n\n; explicit context\n(let [ctx (fc/context)\n      foo (fc/recorded-fake ctx)]\n  ; ...\n)\n\n\n\n\nAlternatively a new context can be created with \n\nclj-fakes.core/with-fakes\n macro:\n\n\n; implicit context\n(f/with-fakes\n  ; note that now fake is created using a macro from core ns\n  (let [foo (f/recorded-fake)]\n    ; ...\n))\n\n\n\n\nThis approach is preferable since it requires less typing, automatically \nunpatches all patched vars and executes self-tests.\n\n\nInternally \nwith-fakes\n relies on a public dynamic var \n*context*\n which can be \nused in your own helper functions.\n\n\nFunction Fakes\n\n\nFake is a function which returns canned values on matched arguments and can optionally record its calls. It \ncan be used to define and assert a behavior of an explicit functional dependency of an SUT (system under test).\n\n\nFake\n\n\nA regular fake function can be created using a macro:\n\n\n(fake [ctx] config)\n\n\nConfig\n is a vector which defines which values to return for different arguments:\n\n\n(let [foo (f/fake [[1 2] \nfoo\n\n                   [3 4 5] \nbar\n])]\n  (foo 1 2) ; =\n \nfoo\n\n  (foo 3 4 5)) ; =\n \nbar\n\n\n\n\n\nIf passed arguments cannot be \nmatched\n using specified config then the exception will be raised:\n\n\n(foo 100 200) ; =\n raises \nUnexpected args are passed into fake: (100 200)\n\n\n\n\n\nA fake is assumed to be called at least once inside the context. Otherwise \nself-test\n exception \nwill be raised. In such case user should either modify a test, an SUT \nor consider using an \noptional fake\n:\n\n\n(f/with-fakes\n  (f/fake [[] nil])) ; =\n raises \nSelf-test: no call detected for: non-optional fake ...\n\n\n\n\n\nIf your test scenario focuses on testing a behavior (e.g. \"assert that foo was called by an SUT\") then do not rely on self-tests, \ninstead use \nrecorded fakes\n with explicit assertions. \nSelf-tests are more about checking sensibility of provided preconditions than \nabout testing expected behavior.\n\n\nOptional Fake\n\n\n(optional-fake [ctx] [config])\n\n\nIt works the same as a regular fake but is not expected to be always called in the context:\n\n\n(f/with-fakes\n  (f/optional-fake [[1 2] 3])) ; =\n ok, self-test will pass\n\n\n\n\nSuch fakes should be used to express the intent of the test writer, \nfor example, when you have to provide a dependency to an SUT,\nbut this dependency is not really related to the test case:\n\n\n(defn process-payments\n  \nProcessor requires a logger.\n\n  [data logger]\n  {:pre [(fn? logger)]}\n  ; ...\n  )\n\n(deftest good-payments-are-processed-without-error\n  (f/with-fakes\n    (let [; ...\n          ; we are not interested in how logger is going to be used, just stub it and forget\n          fake-logger (f/optional-fake)]\n      (is (= :success (process-payments good-payments fake-logger))))))\n\n\n\n\nAs you may have noticed, \nconfig\n argument can be omitted. In such case fake will be created \nwith \n(default-fake-config)\n which allows any arguments to be passed on invocation.\n\n\nRecorded Fake\n\n\n-\n\n\nFake Configuration\n\n\nFake function config should contain pairs of args-matcher \n return-value. On fake invocation \nargument matchers will be tested from top to bottom and on the first match the specified value will be returned.\n\n\nArgument Matching\n\n\n-\n\n\nAssertions\n\n\n-\n\n\nProtocol Fakes\n\n\n-\n\n\nStrict\n\n\n-\n\n\nNice\n\n\n-\n\n\nSelf-tests\n\n\n-\n\n\nUnused Fakes\n\n\n-\n\n\nUnchecked Fakes\n\n\n-\n\n\nMonkey Patching\n\n\n-\n\n\nFunction Spy\n\n\nExample:\n\n\n(f/patch! #'funcs/sum (f/recorded-fake [f/any? funcs/sum]))\n\n\n\n\nReferences\n\n\nThe API was mainly inspired by \njMock\n and \nunittest.mock\n frameworks with\ndesign decisions loosely based on the \n\"Fifteen things I look for in an Isolation framework\" by Roy Osherove\n.\n\n\nSome alternative frameworks with isolation capabilities:\n\n\n\n\nclj-mock\n\n\nMidje\n\n\nspeclj\n\n\n\n\nAlso take at look at the article \n\"Isolating External Dependencies in Clojure\" by Joseph Wilk\n\nwhich discusses different approaches to mocking in Clojure.\n\n\nFor more detailed information about unit testing, TDD and test double patterns I'd recommend the books below:\n\n\n\n\n\"Test Driven Development: By Example\" by Kent Beck\n\n\n\"Growing Object-Oriented Software, Guided by Tests\" by Steve Freeman and Nat Pryce [\nsite\n]\n\n\n\"xUnit Test Patterns: Refactoring Test Code\" by Gerard Meszaros [\nsite\n]", 
            "title": "User Guide"
        }, 
        {
            "location": "/user-guide/#namespaces", 
            "text": "The public API is split into two namespaces:   clj-fakes.core  clj-fakes.context   This is how you could require them in Clojure and ClojureScript:  ; Clojure\n(ns unit.example\n  (:require\n    [clj-fakes.core :as f]\n    [clj-fakes.context :as fc]))\n\n; ClojureScript\n(ns unit.example\n  (:require\n    [clj-fakes.core :as f :include-macros true]\n    [clj-fakes.context :as fc :include-macros true]))  These namespaces contain almost the same set of members. The difference \nis that  core  uses an implicit context and the  context  namespace\nfunctions require an explicit context argument.  For your convenience functions which don't rely on a context can also be sometimes found in both namespaces (e.g.  f/any?  is the same as  fc/any? ).  The private/internal API uses a  -  prefix and should not be used (e.g.  -this-is-some-private-thing ).", 
            "title": "Namespaces"
        }, 
        {
            "location": "/user-guide/#context", 
            "text": "Context is an object which stores all the information about\ncreated fakes (recorded calls, positions in code, etc.).\nAll fakes have to be created inside some context.  To create a new context use  clj-fakes.context/context :  ; explicit context\n(let [ctx (fc/context)\n      foo (fc/recorded-fake ctx)]\n  ; ...\n)  Alternatively a new context can be created with  clj-fakes.core/with-fakes  macro:  ; implicit context\n(f/with-fakes\n  ; note that now fake is created using a macro from core ns\n  (let [foo (f/recorded-fake)]\n    ; ...\n))  This approach is preferable since it requires less typing, automatically \nunpatches all patched vars and executes self-tests.  Internally  with-fakes  relies on a public dynamic var  *context*  which can be \nused in your own helper functions.", 
            "title": "Context"
        }, 
        {
            "location": "/user-guide/#function-fakes", 
            "text": "Fake is a function which returns canned values on matched arguments and can optionally record its calls. It \ncan be used to define and assert a behavior of an explicit functional dependency of an SUT (system under test).", 
            "title": "Function Fakes"
        }, 
        {
            "location": "/user-guide/#fake", 
            "text": "A regular fake function can be created using a macro:  (fake [ctx] config)  Config  is a vector which defines which values to return for different arguments:  (let [foo (f/fake [[1 2]  foo \n                   [3 4 5]  bar ])]\n  (foo 1 2) ; =   foo \n  (foo 3 4 5)) ; =   bar   If passed arguments cannot be  matched  using specified config then the exception will be raised:  (foo 100 200) ; =  raises  Unexpected args are passed into fake: (100 200)   A fake is assumed to be called at least once inside the context. Otherwise  self-test  exception \nwill be raised. In such case user should either modify a test, an SUT \nor consider using an  optional fake :  (f/with-fakes\n  (f/fake [[] nil])) ; =  raises  Self-test: no call detected for: non-optional fake ...   If your test scenario focuses on testing a behavior (e.g. \"assert that foo was called by an SUT\") then do not rely on self-tests, \ninstead use  recorded fakes  with explicit assertions. \nSelf-tests are more about checking sensibility of provided preconditions than \nabout testing expected behavior.", 
            "title": "Fake"
        }, 
        {
            "location": "/user-guide/#optional-fake", 
            "text": "(optional-fake [ctx] [config])  It works the same as a regular fake but is not expected to be always called in the context:  (f/with-fakes\n  (f/optional-fake [[1 2] 3])) ; =  ok, self-test will pass  Such fakes should be used to express the intent of the test writer, \nfor example, when you have to provide a dependency to an SUT,\nbut this dependency is not really related to the test case:  (defn process-payments\n   Processor requires a logger. \n  [data logger]\n  {:pre [(fn? logger)]}\n  ; ...\n  )\n\n(deftest good-payments-are-processed-without-error\n  (f/with-fakes\n    (let [; ...\n          ; we are not interested in how logger is going to be used, just stub it and forget\n          fake-logger (f/optional-fake)]\n      (is (= :success (process-payments good-payments fake-logger))))))  As you may have noticed,  config  argument can be omitted. In such case fake will be created \nwith  (default-fake-config)  which allows any arguments to be passed on invocation.", 
            "title": "Optional Fake"
        }, 
        {
            "location": "/user-guide/#recorded-fake", 
            "text": "-", 
            "title": "Recorded Fake"
        }, 
        {
            "location": "/user-guide/#fake-configuration", 
            "text": "Fake function config should contain pairs of args-matcher   return-value. On fake invocation \nargument matchers will be tested from top to bottom and on the first match the specified value will be returned.", 
            "title": "Fake Configuration"
        }, 
        {
            "location": "/user-guide/#argument-matching", 
            "text": "-", 
            "title": "Argument Matching"
        }, 
        {
            "location": "/user-guide/#assertions", 
            "text": "-", 
            "title": "Assertions"
        }, 
        {
            "location": "/user-guide/#protocol-fakes", 
            "text": "-", 
            "title": "Protocol Fakes"
        }, 
        {
            "location": "/user-guide/#strict", 
            "text": "-", 
            "title": "Strict"
        }, 
        {
            "location": "/user-guide/#nice", 
            "text": "-", 
            "title": "Nice"
        }, 
        {
            "location": "/user-guide/#self-tests", 
            "text": "-", 
            "title": "Self-tests"
        }, 
        {
            "location": "/user-guide/#unused-fakes", 
            "text": "-", 
            "title": "Unused Fakes"
        }, 
        {
            "location": "/user-guide/#unchecked-fakes", 
            "text": "-", 
            "title": "Unchecked Fakes"
        }, 
        {
            "location": "/user-guide/#monkey-patching", 
            "text": "-", 
            "title": "Monkey Patching"
        }, 
        {
            "location": "/user-guide/#function-spy", 
            "text": "Example:  (f/patch! #'funcs/sum (f/recorded-fake [f/any? funcs/sum]))", 
            "title": "Function Spy"
        }, 
        {
            "location": "/user-guide/#references", 
            "text": "The API was mainly inspired by  jMock  and  unittest.mock  frameworks with\ndesign decisions loosely based on the  \"Fifteen things I look for in an Isolation framework\" by Roy Osherove .  Some alternative frameworks with isolation capabilities:   clj-mock  Midje  speclj   Also take at look at the article  \"Isolating External Dependencies in Clojure\" by Joseph Wilk \nwhich discusses different approaches to mocking in Clojure.  For more detailed information about unit testing, TDD and test double patterns I'd recommend the books below:   \"Test Driven Development: By Example\" by Kent Beck  \"Growing Object-Oriented Software, Guided by Tests\" by Steve Freeman and Nat Pryce [ site ]  \"xUnit Test Patterns: Refactoring Test Code\" by Gerard Meszaros [ site ]", 
            "title": "References"
        }, 
        {
            "location": "/dev-guide/", 
            "text": "Some notes for framework developers.\n\n\nTests\n\n\nAutorun Clojure tests: \nlein test-refresh\n\n\nRun ClojureScript tests: \nlein clean \n lein doo phantom test once\n\n(clean is needed because there's an issue: ClojureScript plugin does not seem to recompile macros)\n\n\nAutorun ClojureScript tests: \nfswatch -o ./src ./test | xargs -n1 -I{} sh -c 'echo wait.... \n lein clean \n lein doo rhino test once'\n\n\nDocumentation\n\n\nProject uses \nMkDocs\n to generate documentation static site.\n\n\nBuild: \nmkdocs build\n\n\nServe locally with automatic build: \nmkdocs serve\n\n\nDeploy docs to gh-pages branch: \nmkdocs gh-deploy --clean", 
            "title": "Developer Guide"
        }, 
        {
            "location": "/dev-guide/#tests", 
            "text": "Autorun Clojure tests:  lein test-refresh  Run ClojureScript tests:  lein clean   lein doo phantom test once \n(clean is needed because there's an issue: ClojureScript plugin does not seem to recompile macros)  Autorun ClojureScript tests:  fswatch -o ./src ./test | xargs -n1 -I{} sh -c 'echo wait....   lein clean   lein doo rhino test once'", 
            "title": "Tests"
        }, 
        {
            "location": "/dev-guide/#documentation", 
            "text": "Project uses  MkDocs  to generate documentation static site.  Build:  mkdocs build  Serve locally with automatic build:  mkdocs serve  Deploy docs to gh-pages branch:  mkdocs gh-deploy --clean", 
            "title": "Documentation"
        }
    ]
}