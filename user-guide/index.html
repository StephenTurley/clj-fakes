<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">

	<title>User Guide - clj-fakes</title>

        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">
        <link href="../css/base.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="..">clj-fakes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
                <li >
                    <a href="..">Home</a>
                </li>
            
            
            
                <li class="active">
                    <a href="./">User Guide</a>
                </li>
            
            
            
                <li >
                    <a href="../dev-guide/">Developer Guide</a>
                </li>
            
            
            </ul>

            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                <li >
                    <a rel="next" href="..">
                        <i class="fa fa-arrow-left"></i> Previous
                    </a>
                </li>
                <li >
                    <a rel="prev" href="../dev-guide/">
                        Next <i class="fa fa-arrow-right"></i>
                    </a>
                </li>
                
                <li>
                    <a href="https://github.com/metametadata/clj-fakes/">
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#namespaces">Namespaces</a></li>
        
    
        <li class="main "><a href="#context">Context</a></li>
        
    
        <li class="main "><a href="#function-fakes">Function Fakes</a></li>
        
            <li><a href="#fake">Fake</a></li>
        
            <li><a href="#optional-fake">Optional Fake</a></li>
        
            <li><a href="#recorded-fake">Recorded Fake</a></li>
        
    
        <li class="main "><a href="#fake-configuration">Fake Configuration</a></li>
        
            <li><a href="#default-fake-config">default-fake-config</a></li>
        
    
        <li class="main "><a href="#argument-matching">Argument Matching</a></li>
        
            <li><a href="#protocol">Protocol</a></li>
        
            <li><a href="#functional-matcher">Functional matcher</a></li>
        
            <li><a href="#vector-matcher">Vector matcher</a></li>
        
            <li><a href="#any">any?</a></li>
        
    
        <li class="main "><a href="#protocol-fakes">Protocol Fakes</a></li>
        
            <li><a href="#strict">Strict</a></li>
        
            <li><a href="#nice">Nice</a></li>
        
    
        <li class="main "><a href="#assertions">Assertions</a></li>
        
    
        <li class="main "><a href="#self-tests">Self-tests</a></li>
        
            <li><a href="#unused-fakes">Unused Fakes</a></li>
        
            <li><a href="#unchecked-fakes">Unchecked Fakes</a></li>
        
    
        <li class="main "><a href="#monkey-patching">Monkey Patching</a></li>
        
            <li><a href="#function-spy">Function Spy</a></li>
        
    
        <li class="main "><a href="#references">References</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">

<h1 id="namespaces">Namespaces</h1>
<p>The public API is split into two namespaces:</p>
<ul>
<li><code>clj-fakes.core</code></li>
<li><code>clj-fakes.context</code></li>
</ul>
<p>This is how you could require them in Clojure and ClojureScript:</p>
<pre><code class="clj">; Clojure
(ns unit.example
  (:require
    [clj-fakes.core :as f]
    [clj-fakes.context :as fc]))

; ClojureScript
(ns unit.example
  (:require
    [clj-fakes.core :as f :include-macros true]
    [clj-fakes.context :as fc :include-macros true]))
</code></pre>

<p>These namespaces contain almost the same set of members. The difference 
is that <code>core</code> uses an implicit context and the <code>context</code> namespace
functions require an explicit context argument.</p>
<p>For your convenience functions which don't rely on a context can also be sometimes found in both namespaces (e.g. <code>f/any?</code> is the same as <code>fc/any?</code>).</p>
<p>The private/internal API uses a <code>-</code> prefix and should not be used (e.g. <code>-this-is-some-private-thing</code>).</p>
<h1 id="context">Context</h1>
<p>Context is an object which stores all the information about
created fakes (recorded calls, positions in code, etc.).
All fakes have to be created inside some context.</p>
<p>To create a new context use <code>clj-fakes.context/context</code>:</p>
<pre><code class="clj">; explicit context
(let [ctx (fc/context)
      foo (fc/recorded-fake ctx)]
  ; ...
)
</code></pre>

<p>Alternatively a new context can be created with 
<code>clj-fakes.core/with-fakes</code> macro:</p>
<pre><code class="clj">; implicit context
(f/with-fakes
  ; note that now fake is created using a macro from core ns
  (let [foo (f/recorded-fake)]
    ; ...
))
</code></pre>

<p>This approach is preferable since it requires less typing, automatically 
unpatches all patched vars and executes self-tests.</p>
<p>Internally <code>with-fakes</code> relies on a public dynamic var <code>*context*</code> which can be 
used in your own helper functions.</p>
<h1 id="function-fakes">Function Fakes</h1>
<p>Fake is a function which returns canned values on matched arguments and can optionally record its calls. It 
can be used to define and assert a behavior of an explicit functional dependency of an SUT (system under test).</p>
<h2 id="fake">Fake</h2>
<p>A regular fake function can be created using a macro:</p>
<p><code>(fake [ctx] config)</code></p>
<p><a href="#fake-configuration">Config</a> is a vector which defines which values to return for different arguments:</p>
<pre><code class="clj">(let [foo (f/fake [[1 2] &quot;foo&quot;
                   [3 4 5] &quot;bar&quot;])]
  (foo 1 2) ; =&gt; &quot;foo&quot;
  (foo 3 4 5)) ; =&gt; &quot;bar&quot;
</code></pre>

<p>If passed arguments cannot be <a href="#argument-matching">matched</a> using specified config then the exception will be raised:</p>
<pre><code class="clj">(foo 100 200) ; =&gt; raises &quot;Unexpected args are passed into fake: (100 200)&quot;
</code></pre>

<p>A fake is assumed to be called at least once inside the context. Otherwise <a href="#self-tests">self-test</a> exception 
will be raised. In such case user should either modify a test, an SUT 
or consider using an <a href="#optional-fake">optional fake</a>:</p>
<pre><code class="clj">(f/with-fakes
  (f/fake [[] nil])) ; =&gt; raises &quot;Self-test: no call detected for: non-optional fake ...&quot;
</code></pre>

<p>If your test scenario focuses on testing a behavior (e.g. "assert that foo was called by an SUT") then do not rely on self-tests, 
instead use <a href="#recorded-fake">recorded fakes</a> with explicit assertions. 
Self-tests are more about checking usefulness of provided preconditions than 
about testing expected behavior.</p>
<h2 id="optional-fake">Optional Fake</h2>
<p><code>(optional-fake [ctx] [config])</code></p>
<p>It works the same as a regular fake but is not expected to be always called in the context:</p>
<pre><code class="clj">(f/with-fakes
  (f/optional-fake [[1 2] 3])) ; =&gt; ok, self-test will pass
</code></pre>

<p>Such fakes should be used to express the intent of the test writer, 
for example, when you have to provide a dependency to an SUT,
but this dependency is not really related to the test case:</p>
<pre><code class="clj">(defn process-payments
  &quot;Processor requires a logger.&quot;
  [data logger]
  {:pre [(fn? logger)]}
  ; ...
  )

(deftest good-payments-are-processed-without-error
  (f/with-fakes
    (let [; ...
          ; we are not interested in how logger is going to be used, just stub it and forget
          fake-logger (f/optional-fake)]
      (is (= :success (process-payments good-payments fake-logger))))))
</code></pre>

<p>As you may have noticed, <code>config</code> argument can be omitted. 
In such case fake will be created with <code>(default-fake-config)</code> 
which allows any arguments to be passed on invocation.</p>
<h2 id="recorded-fake">Recorded Fake</h2>
<p>Invocations of this fake are recorded so that they can later be asserted:</p>
<p><code>(recorded-fake [ctx] [config])</code></p>
<p>Use <code>calls</code> function in order to get all recorded invocations for the specified 
recorded fake. 
It can also return all the recorded calls in the context if fake is not specified:</p>
<pre><code class="clj">(let [foo (f/recorded-fake [[integer? integer?] #(+ %1 %2)])
      bar (f/recorded-fake [[integer? integer?] #(* %1 %2)])]
  (foo 1 2)
  (bar 5 6)
  (foo 7 8)

  (f/calls foo)
  ; =&gt; [{:args [1 2] :return-value 3}
  ;     {:args [7 8] :return-value 15}]

  (f/calls)
  ; =&gt; [[foo {:args [1 2] :return-value 3}]
  ;     [bar {:args [5 6] :return-value 30}]
  ;     [foo {:args [7 8] :return-value 15}]]
)
</code></pre>

<p>Recorded fake must be checked using one of the <a href="#assertions">assertions</a> provided by the framework or
be marked as checked explicitly using <code>mark-checked</code> function; otherwise, self-test will raise an exception:</p>
<pre><code class="clj">(f/with-fakes
  (f/recorded-fake)) ; =&gt; raises &quot;Self-test: no check performed on: recorded fake ...&quot;
</code></pre>

<pre><code class="clj">(f/with-fakes
  (let [foo (f/recorded-fake)]
    (f/was-called foo))) ; =&gt; ok, self-test will pass
</code></pre>

<pre><code class="clj">(f/with-fakes
  (f/mark-checked (f/recorded-fake))) ; =&gt; ok, self-test will pass
</code></pre>

<h1 id="fake-configuration">Fake Configuration</h1>
<p>Fake config should contain pairs of argument matcher and return value:</p>
<pre><code class="clj">[args-matcher1 fn-or-value1
args-matcher2 fn-or-value2 ...]
</code></pre>

<p>On fake invocation argument matchers will be tested from top to bottom and 
on the first match the specified value will be returned. If return value is a function than it will be called with passed arguments to generate the return value at runtime:</p>
<pre><code class="clj">(let [foo (f/fake [[1 2] 100
                   [3 4] #(+ %1 %2)])]
  (foo 1 2) ; =&gt; 100
  (foo 3 4)) ; =&gt; 7
</code></pre>

<h2 id="default-fake-config">default-fake-config</h2>
<p><code>fc/default-fake-config</code></p>
<p>This config accepts any arguments and returns a new unique value on each call.
It is used by <code>optional-fake</code> and <code>recorded-fake</code> functions when user 
doesn't specify the config explicitly.</p>
<h1 id="argument-matching">Argument Matching</h1>
<h2 id="protocol">Protocol</h2>
<p>Argument matcher must implement an <code>fc/ArgsMatcher</code> protocol:</p>
<pre><code class="clj">(defprotocol ArgsMatcher
  (args-match? [this args] &quot;Should return true or false.&quot;))
</code></pre>

<p>In most cases you won't need to create instances of this protocol manually 
because framework provides functional and vector matchers which are useful in most cases.</p>
<h2 id="functional-matcher">Functional matcher</h2>
<p>Functional matcher is a function which takes a vector of call arguments and returns true/false. 
Example:</p>
<pre><code class="clj">(let [foo (f/fake [#(odd? (count %)) &quot;odd number of args&quot;
                   #(even? (count %)) &quot;even number of args&quot;])]
  (foo 1 2) ; =&gt; &quot;even number of args&quot;
  (foo 1 2 3)) ; =&gt; &quot;odd number of args&quot;
</code></pre>

<p>It's actually implemented like this:</p>
<pre><code class="clj">(extend-type #?(:clj  clojure.lang.Fn
                :cljs function)
  ArgsMatcher
  (args-match? [this args]
    (this args)))
</code></pre>

<h2 id="vector-matcher">Vector matcher</h2>
<p>Vector matchers were already used all other this guide, they looks like this:</p>
<pre><code class="clj">[value-or-function1 value-or-function2 ...]
</code></pre>

<p>Let's look at the demo:</p>
<pre><code class="clj">(let [foo (f/fake [[] &quot;no args&quot;
                   [[]] &quot;empty vector&quot;
                   [1 2] &quot;1 2&quot;
                   [integer?] &quot;integer&quot;
                   [str?] &quot;string&quot;])]
  (foo) ; =&gt; &quot;no args&quot;
  (foo []) ; =&gt; &quot;empty vector&quot;
  (foo 1 2) ; =&gt; &quot;1 2&quot;
  (foo 1 2 3) ; =&gt; exception: &quot;Unexpected args are passed into fake: (1 2 3)&quot;
  (foo 123) ; =&gt; &quot;integer&quot;
  (foo &quot;hey&quot;)) ; =&gt; &quot;string&quot;
</code></pre>

<h2 id="any">any?</h2>
<p><code>(f/any? args)</code>
<code>(fc/any? args)</code></p>
<p>This matcher always returns <code>true</code> for any input arguments:</p>
<pre><code class="clj">(let [foo (f/fake [[1 2] &quot;1 2&quot;
                   [f/any? f/any? f/any?] &quot;three args&quot;
                   f/any? &quot;something else&quot;])]
  (foo) ; =&gt; &quot;something else&quot;
  (foo 1) ; =&gt; &quot;something else&quot;
  (foo 1 2) ; =&gt; &quot;1 2&quot;
  (foo 1 2 3) ; =&gt; &quot;three args&quot;
  (foo 1 2 3 4)) ; =&gt; &quot;something else&quot;
</code></pre>

<h1 id="protocol-fakes">Protocol Fakes</h1>
<table>
<thead>
<tr>
<th>Feature</th>
<th>reify-fake</th>
<th>reify-nice-fake</th>
</tr>
</thead>
<tbody>
<tr>
<td>Fake protocol method (explicitly)</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Fake protocol method (auto)</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Support overloaded protocol methods</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Fake Java interface method (explicitly)</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Fake Java interface method (auto)</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>Fake Object method (explicitly)</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Fake Object method (auto)</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>Object can be reified with any new methods</td>
<td>No</td>
<td>No</td>
</tr>
</tbody>
</table>
<h2 id="strict">Strict</h2>
<p>-</p>
<h2 id="nice">Nice</h2>
<p>-</p>
<h1 id="assertions">Assertions</h1>
<p>-</p>
<h1 id="self-tests">Self-tests</h1>
<p>-</p>
<h2 id="unused-fakes">Unused Fakes</h2>
<p>-</p>
<h2 id="unchecked-fakes">Unchecked Fakes</h2>
<p>-</p>
<h1 id="monkey-patching">Monkey Patching</h1>
<p>-</p>
<h2 id="function-spy">Function Spy</h2>
<p>Example:</p>
<pre><code class="clj">(f/patch! #'funcs/sum (f/recorded-fake [f/any? funcs/sum]))
</code></pre>

<h1 id="references">References</h1>
<p>The API was mainly inspired by <a href="http://www.jmock.org/">jMock</a> and <a href="https://docs.python.org/3/library/unittest.mock.html">unittest.mock</a> frameworks with
design decisions loosely based on the <a href="http://osherove.com/blog/2013/11/23/fifteen-things-i-look-for-in-an-isolation-framework.html">"Fifteen things I look for in an Isolation framework" by Roy Osherove</a>.</p>
<p>Some alternative frameworks with isolation capabilities:</p>
<ul>
<li><a href="https://github.com/EchoTeam/clj-mock">clj-mock</a></li>
<li><a href="https://github.com/marick/Midje">Midje</a></li>
<li><a href="https://github.com/slagyr/speclj">speclj</a></li>
</ul>
<p>Also take at look at the article <a href="http://blog.josephwilk.net/clojure/isolating-external-dependencies-in-clojure.html">"Isolating External Dependencies in Clojure" by Joseph Wilk</a>
which discusses different approaches to mocking in Clojure.</p>
<p>For more detailed information about unit testing, TDD and test double patterns I'd recommend the books below:</p>
<ul>
<li>"Test Driven Development: By Example" by Kent Beck</li>
<li>"Growing Object-Oriented Software, Guided by Tests" by Steve Freeman and Nat Pryce [<a href="http://www.growing-object-oriented-software.com/">site</a>]</li>
<li>"xUnit Test Patterns: Refactoring Test Code" by Gerard Meszaros [<a href="http://xunitpatterns.com/">site</a>]</li>
</ul></div>
        </div>

        <footer class="col-md-12">
            <hr>
            
            <center>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</center>
        </footer>

        <script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script>
        <script src="../js/base.js"></script>
    </body>
</html>