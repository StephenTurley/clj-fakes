<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">

	<title>User Guide - clj-fakes</title>

        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">
        <link href="../css/base.css" rel="stylesheet">
        <link href="../custom.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="..">clj-fakes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
                <li >
                    <a href="..">Home</a>
                </li>
            
            
            
                <li class="active">
                    <a href="./">User Guide</a>
                </li>
            
            
            
                <li >
                    <a href="../dev-guide/">Developer Guide</a>
                </li>
            
            
            </ul>

            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                <li >
                    <a rel="next" href="..">
                        <i class="fa fa-arrow-left"></i> Previous
                    </a>
                </li>
                <li >
                    <a rel="prev" href="../dev-guide/">
                        Next <i class="fa fa-arrow-right"></i>
                    </a>
                </li>
                
                <li>
                    <a href="https://github.com/metametadata/clj-fakes/">
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#namespaces">Namespaces</a></li>
        
    
        <li class="main "><a href="#context">Context</a></li>
        
    
        <li class="main "><a href="#function-fakes">Function Fakes</a></li>
        
            <li><a href="#fake">Fake</a></li>
        
            <li><a href="#optional-fake">Optional Fake</a></li>
        
            <li><a href="#recorded-fake">Recorded Fake</a></li>
        
    
        <li class="main "><a href="#fake-configuration">Fake Configuration</a></li>
        
    
        <li class="main "><a href="#argument-matching">Argument Matching</a></li>
        
            <li><a href="#built-in-matchers">Built-in matchers</a></li>
        
    
        <li class="main "><a href="#protocol-fakes">Protocol Fakes</a></li>
        
            <li><a href="#syntax">Syntax</a></li>
        
            <li><a href="#calls-assertions">Calls &amp; Assertions</a></li>
        
            <li><a href="#strict">Strict</a></li>
        
            <li><a href="#nice">Nice</a></li>
        
            <li><a href="#custom-macros">Custom Macros</a></li>
        
    
        <li class="main "><a href="#assertions">Assertions</a></li>
        
    
        <li class="main "><a href="#self-tests">Self-tests</a></li>
        
            <li><a href="#unused-fakes">Unused Fakes</a></li>
        
            <li><a href="#unchecked-fakes">Unchecked Fakes</a></li>
        
    
        <li class="main "><a href="#monkey-patching">Monkey Patching</a></li>
        
    
        <li class="main "><a href="#references">References</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">

<h1 id="namespaces">Namespaces</h1>
<p>The public API is split into two namespaces:</p>
<ul>
<li><code>clj-fakes.core</code></li>
<li><code>clj-fakes.context</code></li>
</ul>
<p>This is how you could require them in Clojure and ClojureScript:</p>
<pre><code class="clj">; Clojure
(ns unit.example
  (:require
    [clj-fakes.core :as f]
    [clj-fakes.context :as fc]))

; ClojureScript
(ns unit.example
  (:require
    [clj-fakes.core :as f :include-macros true]
    [clj-fakes.context :as fc :include-macros true]))
</code></pre>

<p>These namespaces contain almost the same set of members. The difference 
is that <code>core</code> uses an implicit context and the <code>context</code> namespace
functions require an explicit context argument.</p>
<p>For your convenience functions which don't rely on a context can also be sometimes found in both namespaces (e.g. <code>f/any?</code> is the same as <code>fc/any?</code>).</p>
<p>The private/internal API uses a <code>-</code> prefix and should not be used (e.g. <code>-this-is-some-private-thing</code>).</p>
<h1 id="context">Context</h1>
<p>Context is an object which stores all the information about
created fakes (recorded calls, positions in code, etc.).
All fakes have to be created inside some context.</p>
<p>To create a new context use <code>clj-fakes.context/context</code>:</p>
<pre><code class="clj">; explicit context
(let [ctx (fc/context)
      foo (fc/recorded-fake ctx)]
  ; ...
)
</code></pre>

<p>Alternatively a new context can be created with 
<code>clj-fakes.core/with-fakes</code> macro:</p>
<pre><code class="clj">; implicit context
(f/with-fakes
  ; note that now fake is created using a macro from core ns
  (let [foo (f/recorded-fake)]
    ; ...
))
</code></pre>

<p>This approach is preferable since it requires less typing, automatically 
unpatches all patched vars and executes self-tests.</p>
<p>Internally <code>with-fakes</code> relies on a public dynamic var <code>*context*</code> which can be 
used in your own helper functions.</p>
<h1 id="function-fakes">Function Fakes</h1>
<p>Fake is a function which returns canned values on matched arguments and can optionally record its calls. It 
can be used to define and assert a behavior of an explicit functional dependency of an SUT (system under test).</p>
<h2 id="fake">Fake</h2>
<p>A regular fake function can be created using a macro:</p>
<p><code>(f/fake config)</code></p>
<p><code>(fc/fake ctx config)</code></p>
<p><a href="#fake-configuration">Config</a> is a vector which defines which values to return for different arguments:</p>
<pre><code class="clj">(let [foo (f/fake [[1 2] &quot;foo&quot;
                   [3 4 5] &quot;bar&quot;])]
  (foo 1 2) ; =&gt; &quot;foo&quot;
  (foo 3 4 5)) ; =&gt; &quot;bar&quot;
</code></pre>

<p>If passed arguments cannot be <a href="#argument-matching">matched</a> using specified config then the exception will be raised:</p>
<pre><code class="clj">(foo 100 200) ; =&gt; raises &quot;Unexpected args are passed into fake: (100 200)&quot;
</code></pre>

<p>A fake is assumed to be called at least once inside the context; otherwise, <a href="#self-tests">self-test</a> exception 
will be raised. In such case user should either modify a test, an SUT 
or consider using an <a href="#optional-fake">optional fake</a>:</p>
<pre><code class="clj">(f/with-fakes
  (f/fake [[] nil])) ; =&gt; raises &quot;Self-test: no call detected for: non-optional fake ...&quot;
</code></pre>

<p>If your test scenario focuses on testing a behavior (e.g. "assert that foo was called by an SUT") then do not rely on self-tests, 
instead use <a href="#recorded-fake">recorded fakes</a> with explicit assertions. 
Self-tests are more about checking usefulness of provided preconditions than 
about testing expected behavior.</p>
<h2 id="optional-fake">Optional Fake</h2>
<p><code>(f/optional-fake [config])</code></p>
<p><code>(fc/optional-fake ctx [config])</code></p>
<p>It works the same as a regular fake but is not expected to be always called in the context:</p>
<pre><code class="clj">(f/with-fakes
  (f/optional-fake [[1 2] 3])) ; =&gt; ok, self-test will pass
</code></pre>

<p>Such fakes should be used to express the intent of the test writer, 
for example, when you have to provide a dependency to an SUT,
but this dependency is not really related to the test case:</p>
<pre><code class="clj">(defn process-payments
  &quot;Processor requires a logger.&quot;
  [data logger]
  {:pre [(fn? logger)]}
  ; ...
  )

(deftest good-payments-are-processed-without-error
  (f/with-fakes
    (let [; ...
          ; we are not interested in how logger is going to be used, just stub it and forget
          fake-logger (f/optional-fake)]
      (is (= :success (process-payments good-payments fake-logger))))))
</code></pre>

<p>As you may have noticed, <code>config</code> argument can be omitted. 
In such case fake will be created with <code>(default-fake-config)</code> 
which allows any arguments to be passed on invocation.</p>
<h2 id="recorded-fake">Recorded Fake</h2>
<p>Invocations of this fake are recorded so that they can later be asserted:</p>
<p><code>(f/recorded-fake [config])</code></p>
<p><code>(fc/recorded-fake ctx [config])</code></p>
<p>Use <code>calls</code> function in order to get all recorded invocations for the specified 
recorded fake. 
It can also return all the recorded calls in the context if fake is not specified:</p>
<pre><code class="clj">(let [foo (f/recorded-fake [[integer? integer?] #(+ %1 %2)])
      bar (f/recorded-fake [[integer? integer?] #(* %1 %2)])]
  (foo 1 2)
  (bar 5 6)
  (foo 7 8)

  (f/calls foo)
  ; =&gt; [{:args [1 2] :return-value 3}
  ;     {:args [7 8] :return-value 15}]

  (f/calls)
  ; =&gt; [[foo {:args [1 2] :return-value 3}]
  ;     [bar {:args [5 6] :return-value 30}]
  ;     [foo {:args [7 8] :return-value 15}]]
)
</code></pre>

<p>Recorded fake must be checked using one of the <a href="#assertions">assertions</a> provided by the framework or
be marked as checked explicitly using <code>mark-checked</code> function; otherwise, self-test will raise an exception:</p>
<pre><code class="clj">(f/with-fakes
  (f/recorded-fake)) ; =&gt; raises &quot;Self-test: no check performed on: recorded fake ...&quot;
</code></pre>

<pre><code class="clj">(f/with-fakes
  (let [foo (f/recorded-fake)]
    (f/was-called foo))) ; =&gt; ok, self-test will pass
</code></pre>

<pre><code class="clj">(f/with-fakes
  (f/mark-checked (f/recorded-fake))) ; =&gt; ok, self-test will pass
</code></pre>

<h1 id="fake-configuration">Fake Configuration</h1>
<p>Fake config should contain pairs of argument matcher and return value:</p>
<pre><code class="clj">[args-matcher1 fn-or-value1
args-matcher2 fn-or-value2 ...]
</code></pre>

<p>On fake invocation argument matchers will be tested from top to bottom and 
on the first match the specified value will be returned. If return value is a function than it will be called with passed arguments to generate the return value at runtime:</p>
<pre><code class="clj">(let [foo (f/fake [[1 2] 100
                   [3 4] #(+ %1 %2)])]
  (foo 1 2) ; =&gt; 100
  (foo 3 4)) ; =&gt; 7
</code></pre>

<p>There's one built-in config in the framework:</p>
<p><code>fc/default-fake-config</code></p>
<p>It accepts any number of arguments and returns a new unique 
instance of protocol <code>fc/FakeReturnValue</code> on each call.
It is used by <code>optional-fake</code> and <code>recorded-fake</code> functions by default (i.e. when user 
doesn't specify the config explicitly).</p>
<h1 id="argument-matching">Argument Matching</h1>
<p>Argument matcher must implement an <code>fc/ArgsMatcher</code> protocol:</p>
<pre><code class="clj">(defprotocol ArgsMatcher
  (args-match? [this args] &quot;Should return true or false.&quot;))
</code></pre>

<p>In most cases you won't need to create instances of this protocol manually 
because framework provides functional and vector matchers which are useful in most cases.</p>
<h2 id="built-in-matchers">Built-in matchers</h2>
<h3 id="functional-matcher">Functional matcher</h3>
<p>Functional matcher is a function which takes a vector of call arguments and returns true/false. 
Example:</p>
<pre><code class="clj">(let [foo (f/fake [#(odd? (count %)) &quot;odd number of args&quot;
                   #(even? (count %)) &quot;even number of args&quot;])]
  (foo 1 2) ; =&gt; &quot;even number of args&quot;
  (foo 1 2 3)) ; =&gt; &quot;odd number of args&quot;
</code></pre>

<p>It's actually implemented like this:</p>
<pre><code class="clj">(extend-type #?(:clj  clojure.lang.Fn
                :cljs function)
  ArgsMatcher
  (args-match? [this args]
    (this args)))
</code></pre>

<h3 id="vector-matcher">Vector matcher</h3>
<p>Vector matchers were already used all other this guide, they looks like this:</p>
<pre><code class="clj">[value-or-function1 value-or-function2 ...]
</code></pre>

<p>Let's look at the demo:</p>
<pre><code class="clj">(let [foo (f/fake [[] &quot;no args&quot;
                   [[]] &quot;empty vector&quot;
                   [1 2] &quot;1 2&quot;
                   [integer?] &quot;integer&quot;
                   [str?] &quot;string&quot;])]
  (foo) ; =&gt; &quot;no args&quot;
  (foo []) ; =&gt; &quot;empty vector&quot;
  (foo 1 2) ; =&gt; &quot;1 2&quot;
  (foo 1 2 3) ; =&gt; exception: &quot;Unexpected args are passed into fake: (1 2 3)&quot;
  (foo 123) ; =&gt; &quot;integer&quot;
  (foo &quot;hey&quot;)) ; =&gt; &quot;string&quot;
</code></pre>

<h3 id="any">any?</h3>
<p><code>(f/any? args)</code>
<code>(fc/any? args)</code></p>
<p>This matcher always returns <code>true</code> for any input arguments:</p>
<pre><code class="clj">(let [foo (f/fake [[1 2] &quot;1 2&quot;
                   [f/any? f/any? f/any?] &quot;three args&quot;
                   f/any? &quot;something else&quot;])]
  (foo) ; =&gt; &quot;something else&quot;
  (foo 1) ; =&gt; &quot;something else&quot;
  (foo 1 2) ; =&gt; &quot;1 2&quot;
  (foo 1 2 3) ; =&gt; &quot;three args&quot;
  (foo 1 2 3 4)) ; =&gt; &quot;something else&quot;
</code></pre>

<h1 id="protocol-fakes">Protocol Fakes</h1>
<p>Framework defines two new macros for reifying protocols 
using function fakes described earlier. So, for example, 
you can record and assert method calls on reified instances.</p>
<p>The <code>reify-fake</code> macro is very similar to <code>reify</code>; in particular, 
created instance will raise an exception 
on calling protocol method which is not defined. On the other hand, 
<code>reify-nice-fake</code> is able to automatically generate implementations 
for methods which are not explicitly defined by user.</p>
<p>There are some subtleties, so here's a table to give you an overview of 
which features are currently supported:</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th><code>reify-fake</code></th>
<th><code>reify-nice-fake</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Fake protocol method (explicitly)</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Fake protocol method (auto)</td>
<td>-</td>
<td>Yes</td>
</tr>
<tr>
<td>Support overloaded protocol methods</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Fake Java interface method (explicitly)</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Fake Java interface method (auto)</td>
<td>-</td>
<td>No</td>
</tr>
<tr>
<td>Fake Object method (explicitly)</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Fake Object method (auto)</td>
<td>-</td>
<td>No</td>
</tr>
<tr>
<td>Object can be reified with any new methods</td>
<td>No</td>
<td>No</td>
</tr>
</tbody>
</table>
<h2 id="syntax">Syntax</h2>
<p>The syntax is very similar to the built-in <code>reify</code> macro:</p>
<pre><code class="clj">(f/reify-fake specs*)
(fc/reify-fake ctx specs*)

(f/reify-nice-fake specs*)
(fc/reify-nice-fake ctx specs*)
</code></pre>

<p>Each spec consists of the protocol or interface name followed by zero
or more method fakes:</p>
<pre><code class="clj">protocol-or-interface-or-Object
(method-name fake-type config)*
</code></pre>

<p>Available fake types:</p>
<ul>
<li><code>:fake</code></li>
<li><code>:optional-fake</code></li>
<li><code>:recorded-fake</code></li>
</ul>
<p>As with function fakes, config can be omitted for <code>:optional-fake</code> and <code>:recorded-fake</code>.</p>
<p>An example:</p>
<pre><code class="clj">(defprotocol AnimalProtocol
  (speak [this] [this name] [this name1 name2])
  (eat [this food drink])
  (sleep [this]))

(defprotocol FileProtocol
  (save [this])
  (scan [this]))

; ...

(f/reify-fake
  p/AnimalProtocol
  (sleep :fake [f/any? &quot;zzz&quot;])
  (speak :recorded-fake)

  p/FileProtocol
  (save :optional-fake)

  java.lang.CharSequence
  (charAt :recorded-fake [f/any? \a]))
</code></pre>

<h3 id="configs">Configs</h3>
<p>-</p>
<h2 id="calls-assertions">Calls &amp; Assertions</h2>
<p>-</p>
<h2 id="strict">Strict</h2>
<p>-</p>
<h3 id="protocol">Protocol</h3>
<p>-</p>
<h3 id="java-interface">Java interface</h3>
<p>-</p>
<h3 id="object">Object</h3>
<p>-</p>
<h4 id="clojure">Clojure</h4>
<p>-</p>
<h4 id="clojurescript">ClojureScript</h4>
<p>-</p>
<h2 id="nice">Nice</h2>
<p>-</p>
<h3 id="protocol_1">Protocol</h3>
<p>-</p>
<h3 id="java-interface_1">Java interface</h3>
<p>-</p>
<h3 id="object_1">Object</h3>
<p>-</p>
<h2 id="custom-macros">Custom Macros</h2>
<p>In your own reusable macros you should use <code>reify-fake*/reify-nice-fake*</code> 
instead of <code>reify-fake/reify-nice-fake</code>:</p>
<pre><code class="clj">(f/reify-fake* form env specs*)
(fc/reify-fake* ctx form env specs*)

(f/reify-nice-fake* form env specs*)
(fc/reify-nice-fake* ctx form env specs*)
</code></pre>

<p>In other words, your macro must explicitly provide <code>&amp;form</code> and <code>&amp;env</code> to framework macros; 
otherwise, due to implementation details, framework will not be 
able to correctly determine fake method line numbers which is crucial for debugging. </p>
<p>For instance:</p>
<pre><code class="clj">(defmacro my-reify-fake
  [&amp; specs]
  `(f/reify-fake* ~&amp;form ~&amp;env ~@specs))
</code></pre>

<p>The framework will warn you if you accidentally use the version of macro without asterisk.</p>
<h1 id="assertions">Assertions</h1>
<p>-</p>
<h1 id="self-tests">Self-tests</h1>
<p>-</p>
<h2 id="unused-fakes">Unused Fakes</h2>
<p>-</p>
<h2 id="unchecked-fakes">Unchecked Fakes</h2>
<p>-</p>
<h1 id="monkey-patching">Monkey Patching</h1>
<p>-</p>
<p>Function spy example:</p>
<pre><code class="clj">(f/patch! #'funcs/sum (f/recorded-fake [f/any? funcs/sum]))
</code></pre>

<h1 id="references">References</h1>
<p>The API was mainly inspired by <a href="http://www.jmock.org/">jMock</a> and <a href="https://docs.python.org/3/library/unittest.mock.html">unittest.mock</a> frameworks with
design decisions loosely based on the <a href="http://osherove.com/blog/2013/11/23/fifteen-things-i-look-for-in-an-isolation-framework.html">"Fifteen things I look for in an Isolation framework" by Roy Osherove</a>.</p>
<p>Some alternative frameworks with isolation capabilities:</p>
<ul>
<li><a href="https://github.com/EchoTeam/clj-mock">clj-mock</a></li>
<li><a href="https://github.com/marick/Midje">Midje</a></li>
<li><a href="https://github.com/slagyr/speclj">speclj</a></li>
</ul>
<p>Also take at look at the article <a href="http://blog.josephwilk.net/clojure/isolating-external-dependencies-in-clojure.html">"Isolating External Dependencies in Clojure" by Joseph Wilk</a>
which discusses different approaches to mocking in Clojure.</p>
<p>For more detailed information about unit testing, TDD and test double patterns I'd recommend the books below:</p>
<ul>
<li>"Test Driven Development: By Example" by Kent Beck</li>
<li>"Growing Object-Oriented Software, Guided by Tests" by Steve Freeman and Nat Pryce [<a href="http://www.growing-object-oriented-software.com/">site</a>]</li>
<li>"xUnit Test Patterns: Refactoring Test Code" by Gerard Meszaros [<a href="http://xunitpatterns.com/">site</a>]</li>
</ul></div>
        </div>

        <footer class="col-md-12">
            <hr>
            
            <center>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</center>
        </footer>

        <script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script>
        <script src="../js/base.js"></script>
    </body>
</html>